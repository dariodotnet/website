# Commands

`ReactiveCommand` es una Reactive Extensions e implemetación asíncrona consciente de la interface [`ICommand`](https://msdn.microsoft.com/es-es/library/system.windows.input.icommand.aspx). 

`ICommand` es utilizado a menudo en el [patrón de disño MVVM](https://docs.microsoft.com/es-es/dotnet/framework/wpf/advanced/commanding-overview) para permitir a la View disparar la lógica de negocio definida en el ViewModel. Esto permite matener fácilmente el código, realizar pruebas unitarias y la posibilidad de reutilizar los ViewModels en diferentes frameworks de UI. Ejemplos de dónde una vista debe invocar un command incluye cuando hacemos click en *Guardar* en el menú de nuestra aplicación, pulsando sobre el icono del teléfono, o cambiando una imagen. En estos casos, el ViewModelinvocará la lógica de negocio guardando los cambios, haciendo una llamada telefónica o cambiando el zoom en una imagen.

`ReactiveCommand` a;ade el concepto de entrada (Input) y salida (Output) genérica de tipos. El Input es pasado a menudo por la vist y el Output es el resultado de ejecutar el command. Los `ReactiveCommand` son observables de tipo `IObservable<TOutput>` que pueden ser utilizados como cualquier otro IObservable. Por ejemplo, como `ReactiveCommand` es un `IObservable<TOutput>` puedes hacer `Subscribe()` como en cualquier otro observable y añadir el Output a una lista de tu ViewModel. El tipo `Unit` es un elemento de la programación funcional análgo a void y pude utilizarse en los casos en los que no necesitamos valores para nuestro Input o el Output.

`ReactiveCommand` tiene soporte completo para lógica asíncrona y bloquerá los intentos de una nueva ejecución. `ReactiveCommand` garantiza el resultado de los events entregados a través del `IScheduler` provisto (por defecto será el main thread scheduler). La ejecución de la lógica en hilos de modo seguro es reponsabilidad del usuairo, pero cualquier resultado desde la lógica se garantiza que llegará al `IScheduler` especificado.

Un `ReactiveCommand` es creado utilizando una factoría estática de métodos, los cuales te permiten crear la lógica del command en modo síncrono y asíncrono. Los métodos disponibles en la factoría estática son los siguientes:

* `CreateFromTask()` - Ejecuta una Task C# [Task Parallel Library (TPL)](https://docs.microsoft.com/es-es/dotnet/standard/parallel-programming/task-based-asynchronous-programming). Esto permite utilizar también los operadores de C# [async/await](https://docs.microsoft.com/es-es/dotnet/csharp/language-reference/keywords/async).
* `CreateFromObservable()` - Ejecuta la lógica utilizando un `IObservable`.
* `Create()` - Ejecuta una Func o una Action de modo síncrono.

Un `ReactiveCommand` puede o no ser ejecutado dada una situación. Por ejemplo, el command *Guardar* del menú de tu aplicación no está habilitado si no hay cambios pendientes. Pasamos a nuestro `ReactiveCommand` un `IObservable<bool>` para definir cuando debe permitir la ejecución. El `ReactiveCommand` utiliza el sistema de eventos de un IObservable para determinar si la ejecución debe ser permitida, lo cual difiere de otros frameworks donde tu debes comprobar en cada ocasión si la ejecución está permitida. La aproximación de `ReactiveCommand` tiene algunas ventajas de rendimiento ya que el valor de si es posible ejecutar es guardado cada vez que se dispara el evento. Comunmente crearás tu observable `canExecute` utilianzon las [funciones de `WhenAnyValue`](../when-any/index.md) provistas por ReactiveUI. Los parámetros, al contrario que en otros frameworks, no son utilizados en las condiciones del `canExecute`. En su lugar, es más habitual utilizar propiedades de nuestro ViewModel que están haciendo binding con propiedades de nuestra View.

`ReactiveCommand` está completamente integrado las Reactive Extensions. `ReactiveCommand` provee de la propiedad `IsExecuting` (también de tipo `IObservalbe<bool>`) que te cuenta cuando el command está en ejecución. Esto es muy útil si quieres lanzar animaciones o quieres prevenir que se ejecuten otros command cuando haya alguno en ejecución.

`ReactiveCommand` puede ser conectado con la VIew utilizando los binding de XAML en las plataformas soportadas o utilizando el método `BindCommand` que provee [ReactiveUI para binding](../data-binding/index.md). Es recomendable utilizar `BindCommand` en lugar del binding en XAML, pero ambos son soportados.

`ReactiveCommand` implementa la interface `ICommand` para los frameworks UI con compatibilidad y sólo para versiones anteriores. Es recomendable no utilizar la interface `ICommand` directamente en tu código. `ReactiveCommand` es derivado explícitamente de la interfaqce `ICommand` para evitar que los usuarios llamen accidentalmente a métodos con estilo no reactive. Los métodos de `ICommand` no se prestan bien a realizar acciones asíncronas de larga duración, como métodos de acceso a disco I/O. `ICommand` también se enfoca en un estulo imperativo de ejecución sobre un estilo reactive. `ReactiveCommand` provee de métodos y propiedades observable que son el equivalentes a los de la interface `ICommand`. `Execute()` provee un Observable al cual te puedes `Subscribe()` para ejecutar la lógica del `ReactiveCommand` y `CanExecute` es también expesto como una propiedad de sólo lectura. Adicionalmente `ReactiveCommand` provee del observable `IsExecuting` el cual es una funcionalidad no provista por la interface `ICommand`.
